var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MeasureBase","category":"page"},{"location":"#MeasureBase","page":"Home","title":"MeasureBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MeasureBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MeasureBase]","category":"page"},{"location":"#MeasureBase.Density","page":"Home","title":"MeasureBase.Density","text":"struct Density{M,B}\n    Î¼::M\n    base::B\nend\n\nFor measures Î¼ and Î½ with Î¼â‰ªÎ½, the density of Î¼ with respect to Î½ (also called the Radon-Nikodym derivative dÎ¼/dÎ½) is a function f defined on the support of Î½ with the property that for any measurable a âŠ‚ supp(Î½), Î¼(a) = âˆ«â‚ f dÎ½.\n\nBecause this function is often difficult to express in closed form, there are many different ways of computing it. We therefore provide a formal representation to allow comptuational flexibilty.\n\n\n\n\n\n","category":"type"},{"location":"#MeasureBase.DensityMeasure","page":"Home","title":"MeasureBase.DensityMeasure","text":"struct DensityMeasure{F,B} <: AbstractMeasure\n    density :: F\n    base    :: B\nend\n\nA DensityMeasure is a measure defined by a density with respect to some other \"base\" measure \n\n\n\n\n\n","category":"type"},{"location":"#MeasureBase.SuperpositionMeasure","page":"Home","title":"MeasureBase.SuperpositionMeasure","text":"struct SuperpositionMeasure{X,NT} <: AbstractMeasure\n    components :: NT\nend\n\nSuperposition of measures is analogous to mixture distributions, but (because measures need not be normalized) requires no scaling.\n\nThe superposition of two measures Î¼ and Î½ can be more concisely written as Î¼ + Î½.\n\n\n\n\n\n","category":"type"},{"location":"#MeasureBase.WeightedMeasure","page":"Home","title":"MeasureBase.WeightedMeasure","text":"struct WeightedMeasure{R,M} <: AbstractMeasure\n    logweight :: R\n    base :: M\nend\n\n\n\n\n\n","category":"type"},{"location":"#MeasureBase.:â‰ƒ-Tuple{Any, Any}","page":"Home","title":"MeasureBase.:â‰ƒ","text":"â‰ƒ(Î¼,Î½)\n\nEquivalence of Measure\n\nMeasures Î¼ and Î½ on the same space X are equivalent, written Î¼ â‰ƒ Î½, if Î¼ â‰ª Î½ and Î½ â‰ª Î¼. Note that this is often written ~ in the literature, but this is overloaded in probabilistic programming, so we use this alternate notation. \n\nAlso note that equivalence is very different from equality. For two equivalent measures, the sets of non-zero measure will be identical, but what that measure is in each case can be very different. \n\n\n\n\n\n","category":"method"},{"location":"#MeasureBase.:â‰ª","page":"Home","title":"MeasureBase.:â‰ª","text":"â‰ª(Î¼,Î½)\n\nAbsolute continuity\n\nA measure Î¼ is absolutely continuous with respect to Î½, written Î¼ â‰ª Î½, if Î½(A)==0 implies Î¼(A)==0 for every Î½-measurable set A.\n\nLess formally, suppose we have a set A with Î½(A)==0. If Î¼(A)â‰ 0, then there can be no way to \"reweight\" Î½ to get to Î¼. We can't make something from nothing.\n\nThis \"reweighting\" is really a density function. If Î¼â‰ªÎ½, then there is some function f that makes Î¼ == âˆ«(f,Î½) (see the help section for âˆ«).\n\nWe can get this f directly via the Radon-Nikodym derivative, f == ğ’¹(Î¼,Î½) (see the help section for ğ’¹).\n\nNote that â‰ª is not a partial order, because it is not antisymmetric. That is to say, it's possible (in fact, common) to have two different measures Î¼ and Î½ with Î¼ â‰ª Î½ and Î½ â‰ª Î¼. A simple example of this is \n\nÎ¼ = Normal()\nÎ½ = Lebesgue(â„)\n\nWhen â‰ª holds in both directions, the measures Î¼ and Î½ are equivalent, written Î¼ â‰ƒ Î½. See the help section for â‰ƒ for more information.\n\n\n\n\n\n","category":"function"},{"location":"#MeasureBase.For-Tuple{Any, Vararg{Any, N} where N}","page":"Home","title":"MeasureBase.For","text":"For(f, base...)\n\nFor provides a convenient way to construct a ProductMeasure. There are several options for the base. With Julia's do notation, this can look very similar to a standard for loop, while maintaining semantics structure that's easier to work with.\n\n\n\nFor(f, base::Int...)\n\nWhen one or several Int values are passed for base, the result is treated as depending on CartesianIndices(base). \n\njulia> For(3) do Î» Exponential(Î») end |> marginals\n3-element mappedarray(MeasureTheory.var\"#17#18\"{var\"#15#16\"}(var\"#15#16\"()), ::CartesianIndices{1, Tuple{Base.OneTo{Int64}}}) with eltype Exponential{(:Î»,), Tuple{Int64}}:\n Exponential(Î» = 1,)\n Exponential(Î» = 2,)\n Exponential(Î» = 3,)\n\njulia> For(4,3) do Î¼,Ïƒ Normal(Î¼,Ïƒ) end |> marginals\n4Ã—3 mappedarray(MeasureTheory.var\"#17#18\"{var\"#11#12\"}(var\"#11#12\"()), ::CartesianIndices{2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}) with eltype Normal{(:Î¼, :Ïƒ), Tuple{Int64, Int64}}:\n Normal(Î¼ = 1, Ïƒ = 1)  Normal(Î¼ = 1, Ïƒ = 2)  Normal(Î¼ = 1, Ïƒ = 3)\n Normal(Î¼ = 2, Ïƒ = 1)  Normal(Î¼ = 2, Ïƒ = 2)  Normal(Î¼ = 2, Ïƒ = 3)\n Normal(Î¼ = 3, Ïƒ = 1)  Normal(Î¼ = 3, Ïƒ = 2)  Normal(Î¼ = 3, Ïƒ = 3)\n Normal(Î¼ = 4, Ïƒ = 1)  Normal(Î¼ = 4, Ïƒ = 2)  Normal(Î¼ = 4, Ïƒ = 3)\n\n\n\nFor(f, base::AbstractArray...)`\n\nIn this case, base behaves as if the arrays are zipped together before applying the map.\n\njulia> For(randn(3)) do x Exponential(x) end |> marginals\n3-element mappedarray(x->Main.Exponential(x), ::Vector{Float64}) with eltype Exponential{(:Î»,), Tuple{Float64}}:\n Exponential(Î» = -0.268256,)\n Exponential(Î» = 1.53044,)\n Exponential(Î» = -1.08839,)\n\njulia> For(1:3, 1:3) do Î¼,Ïƒ Normal(Î¼,Ïƒ) end |> marginals\n3-element mappedarray((:Î¼, :Ïƒ)->Main.Normal(Î¼, Ïƒ), ::UnitRange{Int64}, ::UnitRange{Int64}) with eltype Normal{(:Î¼, :Ïƒ), Tuple{Int64, Int64}}:\n Normal(Î¼ = 1, Ïƒ = 1)\n Normal(Î¼ = 2, Ïƒ = 2)\n Normal(Î¼ = 3, Ïƒ = 3)\n\n\n\nFor(f, base::Base.Generator)\n\nFor Generators, the function maps over the values of the generator:\n\njulia> For(eachrow(rand(4,2))) do x Normal(x[1], x[2]) end |> marginals |> collect\n4-element Vector{Normal{(:Î¼, :Ïƒ), Tuple{Float64, Float64}}}:\n Normal(Î¼ = 0.255024, Ïƒ = 0.570142)\n Normal(Î¼ = 0.970706, Ïƒ = 0.0776745)\n Normal(Î¼ = 0.731491, Ïƒ = 0.505837)\n Normal(Î¼ = 0.563112, Ïƒ = 0.98307)\n\n\n\n\n\n","category":"method"},{"location":"#MeasureBase.basemeasure","page":"Home","title":"MeasureBase.basemeasure","text":"basemeasure(Î¼)\n\nMany measures are defined in terms of a logdensity relative to some base measure. This makes it important to be able to find that base measure.\n\nFor measures not defined in this way, we'll typically have basemeasure(Î¼) == Î¼.\n\n\n\n\n\n","category":"function"},{"location":"#MeasureBase.isprimitive-Tuple{Any}","page":"Home","title":"MeasureBase.isprimitive","text":"isprimitive(Î¼)\n\nMost measures are defined in terms of other measures, for example using a density or a pushforward. Those that are not are considered (in this library, it's not a general measure theory thing) to be primitive. The canonical example of a primitive measure is Lebesgue(X) for some X.\n\nThe default method is     isprimitive(Î¼) = false\n\nSo when adding a new primitive measure, it's necessary to add a method for its type that returns true.\n\n\n\n\n\n","category":"method"},{"location":"#MeasureBase.kernel","page":"Home","title":"MeasureBase.kernel","text":"kernel(f, M)\nkernel((f1, f2, ...), M)\n\nA kernel Îº = kernel(f, m) returns a wrapper around a function f giving the parameters for a measure of type M, such that Îº(x) = M(f(x)...) respective Îº(x) = M(f1(x), f2(x), ...)\n\nIf the argument is a named tuple (;a=f1, b=f1), Îº(x) is defined as M(;a=f(x),b=g(x)).\n\nReference\n\nhttps://en.wikipedia.org/wiki/Markov_kernel\n\n\n\n\n\n","category":"function"},{"location":"#MeasureBase.logdensity","page":"Home","title":"MeasureBase.logdensity","text":"logdensity(Î¼::AbstractMeasure{X}, x::X)\n\nCompute the logdensity of the measure Î¼ at the point x. This is the standard way to define logdensity for a new measure. the base measure is implicit here, and is understood to be basemeasure(Î¼).\n\nMethods for computing density relative to other measures will be\n\n\n\n\n\n","category":"function"},{"location":"#MeasureBase.representative-Tuple{Any}","page":"Home","title":"MeasureBase.representative","text":"representative(Î¼::AbstractMeasure) -> AbstractMeasure\n\n\n\n\n\n","category":"method"},{"location":"#MeasureBase.âˆ«-Tuple{Any, AbstractMeasure}","page":"Home","title":"MeasureBase.âˆ«","text":"âˆ«(f, base::AbstractMeasure; log=true)\n\nDefine a new measure in terms of a density f over some measure base. If log=true (the default), f is considered as a log-density.\n\n\n\n\n\n","category":"method"},{"location":"#MeasureBase.ğ’¹-Tuple{AbstractMeasure, AbstractMeasure}","page":"Home","title":"MeasureBase.ğ’¹","text":"ğ’¹(Î¼::AbstractMeasure, base::AbstractMeasure; log=true)\n\nCompute the Radom-Nikodym derivative (or its log, if log=true) of Î¼ with respect to base.\n\n\n\n\n\n","category":"method"},{"location":"#MeasureBase.@domain-Tuple{Any, Any}","page":"Home","title":"MeasureBase.@domain","text":"@domain(name, T)\n\nDefines a new singleton struct T, and a value name for building values of that type.\n\nFor example, @domain â„ RealNumbers is equivalent to\n\nstruct RealNumbers <: AbstractDomain end\n\nexport â„\n\nâ„ = RealNumbers()\n\nBase.show(io::IO, ::RealNumbers) = print(io, \"â„\")\n\n\n\n\n\n","category":"macro"},{"location":"#MeasureBase.@measure-Tuple{Any}","page":"Home","title":"MeasureBase.@measure","text":"@measure <declaration>\n\nThe <declaration> gives a measure and its default parameters, and specifies its relation to its base measure. For example,\n\n@measure Normal(Î¼,Ïƒ) â‰ƒ Lebesgue{X}\n\ndeclares the Normal is a measure with default parameters Î¼ and Ïƒ, and it is equivalent to its base measure, which is Lebesgue{X}\n\nYou can see the generated code like this:\n\njulia> MacroTools.prettify(@macroexpand @measure Normal(Î¼,Ïƒ) â‰ƒ Lebesgue{X})\nquote\n    struct Normal{P, X} <: AbstractMeasure\n        par::P\n    end\n    function Normal(nt::NamedTuple)\n        P = typeof(nt)\n        return Normal{P, eltype(Normal{P})}\n    end\n    Normal(; kwargs...) = Normal((; kwargs...))\n    (basemeasure(Î¼::Normal{P, X}) where {P, X}) = Lebesgue{X}\n    Normal(Î¼, Ïƒ) = Normal(; Any[:Î¼, :Ïƒ])\n    ((:â‰ª)(::Normal{P, X}, ::Lebesgue{X}) where {P, X}) = true\n    ((:â‰ª)(::Lebesgue{X}, ::Normal{P, X}) where {P, X}) = true\nend\n\nNote that the eltype function needs to be defined separately by the user.\n\n\n\n\n\n","category":"macro"}]
}
